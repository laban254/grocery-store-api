name: Continuous Delivery

on:
  push:
    branches: [ "staging" ]
    paths-ignore:
      - "README.md"
      - "KUBERNETES.md"
      - "DOCKER.md"
      - "STARTUP.md"
      - "*.md"
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: grocery_api
      IMAGE_TAG: latest
      NAMESPACE: grocery-api

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build and export Docker image
      run: |
        echo "Building Docker image..."
        docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
        docker save ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} > ${{ env.IMAGE_NAME }}.tar
        echo "Docker image built and saved successfully"

    - name: Set up SSH and deploy
      run: |
        echo "Setting up SSH connection..."
        mkdir -p ~/.ssh
        echo "${{ secrets.GCP_SSH_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519

        # Debug step (will mask sensitive data)
        echo "SERVER_HOST is set: ${{ secrets.SERVER_HOST != '' }}"
        echo "SERVER_USER is set: ${{ secrets.SERVER_USER != '' }}"

        # Validate secrets are set
        if [ -z "${{ secrets.SERVER_HOST }}" ]; then
          echo "ERROR: SERVER_HOST secret is not set"
          exit 1
        fi

        if [ -z "${{ secrets.SERVER_USER }}" ]; then
          echo "ERROR: SERVER_USER secret is not set"
          exit 1
        fi

        # Add server to known hosts
        ssh-keyscan -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts
        echo "SSH keyscan completed"

        # Test connection
        echo "Testing SSH connection..."
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" 'echo "Connected successfully!"'

        # Upload Docker image
        echo "Uploading Docker image..."
        scp -i ~/.ssh/id_ed25519 ${{ env.IMAGE_NAME }}.tar ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/${{ env.IMAGE_NAME }}.tar
        echo "Image uploaded successfully"

        # Load Docker image on remote server
        echo "Loading Docker image on remote server..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "docker load < ${{ env.IMAGE_NAME }}.tar"

        # Clone or update repository
        echo "Updating deployment files on remote server..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          if [ ! -d ~/grocery_api_deploy ]; then
            git clone git@github.com:laban254/grocery-store-api.git ~/grocery_api_deploy
          else
            cd ~/grocery_api_deploy && git pull origin staging
          fi
        "

        # Apply Kubernetes configurations
        echo "Applying Kubernetes configurations..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          cd ~/grocery_api_deploy &&
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f - &&
          kubectl apply -f k8s/env-configmap.yaml -n ${{ env.NAMESPACE }} &&
          kubectl apply -f k8s/web-cm0-configmap.yaml -n ${{ env.NAMESPACE }} &&
          kubectl apply -f k8s/celery-cm0-configmap.yaml -n ${{ env.NAMESPACE }} &&
          kubectl apply -f k8s/db-deployment.yaml -f k8s/db-service.yaml -n ${{ env.NAMESPACE }} &&
          kubectl apply -f k8s/redis-deployment.yaml -f k8s/redis-service.yaml -n ${{ env.NAMESPACE }}
        "

        # Wait for database
        echo "Waiting for database to be ready..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          kubectl wait --for=condition=available deployment/db --timeout=120s -n ${{ env.NAMESPACE }} || true
        "

        # Deploy web and celery
        echo "Deploying web and celery services..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          cd ~/grocery_api_deploy &&
          kubectl apply -f k8s/web-deployment.yaml -f k8s/web-service.yaml -n ${{ env.NAMESPACE }} &&
          kubectl apply -f k8s/celery-deployment.yaml -n ${{ env.NAMESPACE }}
        "

        # Check deployment status
        echo "Checking deployment status..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          kubectl get pods -n ${{ env.NAMESPACE }}
        "

        # Verify and cleanup
        echo "Verifying deployment and cleaning up..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "
          kubectl get services -n ${{ env.NAMESPACE }} &&
          WEB_URL=\$(kubectl get service web -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.clusterIP}') &&
          echo \"Web service is available at: \$WEB_URL\" &&
          rm -f ~/${{ env.IMAGE_NAME }}.tar
        "

        echo "Deployment complete!"
