name: Continuous Delivery

on:
  push:
    branches: [ "main" ]
    paths-ignore:
      - "README.md"
      - "KUBERNETES.md"
      - "DOCKER.md"
      - "STARTUP.md"
      - "*.md"
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: grocery_api
      IMAGE_TAG: latest
      NAMESPACE: grocery-api

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build and export Docker image
      run: |
        echo "Building Docker image..."
        docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
        docker save ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} > ${{ env.IMAGE_NAME }}.tar
        echo "Docker image built and saved successfully"

    - name: Set up SSH and deploy
      run: |
        echo "Setting up SSH connection..."
        mkdir -p ~/.ssh

        # Debug all secrets availability (without revealing their values)
        echo "### DEBUGGING SECRET AVAILABILITY ###"
        echo "GCP_SSH_KEY is empty: ${{ secrets.GCP_SSH_KEY == '' }}"
        echo "SERVER_HOST is empty: ${{ secrets.SERVER_HOST == '' }}"
        echo "SERVER_USER is empty: ${{ secrets.SERVER_USER == '' }}"
        echo "GCP_SSH_KEY length: ${{ secrets.GCP_SSH_KEY != '' && '(not empty)' || '(empty)' }}"
        echo "SERVER_HOST length: ${{ secrets.SERVER_HOST != '' && '(not empty)' || '(empty)' }}"
        echo "SERVER_USER length: ${{ secrets.SERVER_USER != '' && '(not empty)' || '(empty)' }}"
        echo "###################################"

        # Check for SSH key specifically
        if [ -z "${{ secrets.GCP_SSH_KEY }}" ]; then
          echo "ERROR: GCP_SSH_KEY secret is not set or is empty"
          exit 1
        fi

        echo "${{ secrets.GCP_SSH_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519

        # Check if the SSH key file was created properly
        if [ ! -s ~/.ssh/id_ed25519 ]; then
          echo "ERROR: SSH key file is empty after writing"
          exit 1
        else
          echo "SSH key file created successfully with content"
        fi

        # Validate SERVER_HOST
        if [ -z "${{ secrets.SERVER_HOST }}" ]; then
          echo "ERROR: SERVER_HOST secret is not set or is empty"
          exit 1
        fi

        # Validate SERVER_USER
        if [ -z "${{ secrets.SERVER_USER }}" ]; then
          echo "ERROR: SERVER_USER secret is not set or is empty"
          exit 1
        fi

        # Add server to known hosts
        ssh-keyscan -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts
        echo "SSH keyscan completed"

        # Test connection
        echo "Testing SSH connection..."
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" 'echo "Connected successfully!"'

        # Upload Docker image
        echo "Uploading Docker image..."
        scp -i ~/.ssh/id_ed25519 ${{ env.IMAGE_NAME }}.tar ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/${{ env.IMAGE_NAME }}.tar
        echo "Image uploaded successfully"

        # Execute all deployment commands in a single SSH session
        echo "Executing deployment commands..."
        ssh -i ~/.ssh/id_ed25519 "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" << EOF
          # Load the Docker image
          echo "Loading Docker image..."
          docker load < ${{ env.IMAGE_NAME }}.tar

          # Clone or update deployment repository
          echo "Updating deployment files..."
          mkdir -p ~/grocery_api_deploy
          if [ ! -d ~/grocery_api_deploy/.git ]; then
            git clone \$(git config --get remote.origin.url) ~/grocery_api_deploy
          else
            cd ~/grocery_api_deploy
            git pull
          fi

          # Apply Kubernetes manifests
          cd ~/grocery_api_deploy

          # Create namespace if it doesn't exist
          echo "Creating/verifying namespace..."
          kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -

          # Apply ConfigMaps first
          echo "Applying ConfigMaps..."
          kubectl apply -f k8s/env-configmap.yaml -n ${NAMESPACE}
          kubectl apply -f k8s/web-cm0-configmap.yaml -n ${NAMESPACE}
          kubectl apply -f k8s/celery-cm0-configmap.yaml -n ${NAMESPACE}

          # Apply database and Redis
          echo "Deploying database and Redis..."
          kubectl apply -f k8s/db-deployment.yaml -f k8s/db-service.yaml -n ${NAMESPACE}
          kubectl apply -f k8s/redis-deployment.yaml -f k8s/redis-service.yaml -n ${NAMESPACE}

          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          kubectl wait --for=condition=available deployment/db --timeout=120s -n ${NAMESPACE} || true

          # Apply web and celery deployments
          echo "Deploying web and celery services..."
          kubectl apply -f k8s/web-deployment.yaml -f k8s/web-service.yaml -n ${NAMESPACE}
          kubectl apply -f k8s/celery-deployment.yaml -n ${NAMESPACE}

          # Check deployment status
          echo "Checking deployment status..."
          kubectl get pods -n ${NAMESPACE}

          # Get web service URL and verify the deployment
          echo "Verifying deployment..."
          kubectl get services -n ${NAMESPACE}
          WEB_URL=\$(kubectl get service web -n ${NAMESPACE} -o jsonpath='{.spec.clusterIP}')
          echo "Web service is available at: \$WEB_URL"

          # Clean up
          echo "Cleaning up..."
          rm -f ~/${{ env.IMAGE_NAME }}.tar
          echo "Deployment complete!"
